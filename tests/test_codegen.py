from pathlib import Path

from safelang import parse_functions, generate_c, generate_rust, compile_to_nasm
import pytest


def _load_example_funcs():
    src = Path(__file__).resolve().parents[1] / "example.slang"
    return parse_functions(src.read_text())


def _load_bad_funcs():
    src = """
function "bad" {
    @space 0B
    @time 0
    consume { foo(x) }
}
"""
    return parse_functions(src)


def _load_malformed_funcs():
    src = """
function "bad" {
    @space 0B
    @time 0
    consume { int64 x }
}
"""
    return parse_functions(src)


def test_generate_c_contains_clamp_params():
    funcs = _load_example_funcs()
    c_code = generate_c(funcs)
    assert c_code.startswith("// Generated by SafeLang")
    assert "clamp_params" in c_code


def test_generate_c_zero_params_emit_void():
    src = """
function "noop" {
    @space 0B
    @time 0ns

    consume { nil }

    emit { nil }

    return
}
"""
    funcs = parse_functions(src)
    c_code = generate_c(funcs)
    assert "void noop(void)" in c_code


def test_generate_rust_contains_clamp_params():
    funcs = _load_example_funcs()
    rust_code = generate_rust(funcs)
    assert "pub fn clamp_params" in rust_code


def test_generate_c_omits_annotations():
    funcs = _load_example_funcs()
    c_code = generate_c(funcs)
    for ln in c_code.splitlines():
        stripped = ln.strip()
        assert not (
            stripped.startswith("@space")
            or stripped.startswith("consume")
            or stripped.startswith("emit")
        )


def test_generate_rust_omits_annotations():
    funcs = _load_example_funcs()
    rust_code = generate_rust(funcs)
    for ln in rust_code.splitlines():
        stripped = ln.strip()
        assert not (
            stripped.startswith("@space")
            or stripped.startswith("consume")
            or stripped.startswith("emit")
        )


def test_compile_to_nasm_simple_add():
    src = """
function "add" {
    @space 0B
    @time 0ns

    consume {
        int64(a)
        int64(b)
    }

    emit {
        int64(r)
    }

    return a + b
}
"""
    funcs = parse_functions(src)
    asm = compile_to_nasm(funcs)
    assert "global add" in asm
    assert "add:" in asm
    assert "mov rax, rdi" in asm
    assert "add rax, rsi" in asm


def test_compile_to_nasm_too_many_params():
    src = """
function "many" {
    @space 0B
    @time 0ns

    consume {
        int64(p1)
        int64(p2)
        int64(p3)
        int64(p4)
        int64(p5)
        int64(p6)
        int64(p7)
    }

    emit { int64(r) }

    return p1
}
"""
    funcs = parse_functions(src)
    with pytest.raises(ValueError, match="too many parameters"):
        compile_to_nasm(funcs)


def test_generate_c_unknown_type_raises():
    funcs = _load_bad_funcs()
    with pytest.raises(ValueError, match="Unknown type: foo"):
        generate_c(funcs)


def test_generate_rust_unknown_type_raises():
    funcs = _load_bad_funcs()
    with pytest.raises(ValueError, match="Unknown type: foo"):
        generate_rust(funcs)


def test_generate_c_malformed_param_raises():
    funcs = _load_malformed_funcs()
    with pytest.raises(ValueError, match="Malformed parameter"):
        generate_c(funcs)


def test_generate_rust_malformed_param_raises():
    funcs = _load_malformed_funcs()
    with pytest.raises(ValueError, match="Malformed parameter"):
        generate_rust(funcs)
