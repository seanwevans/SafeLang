"""Minimal NASM compiler for SafeLang functions."""

"""Simple SafeLang to C code generator."""

from __future__ import annotations
from typing import List
import re

from .parser import FunctionDef

_TYPE_MAP = {
    "f32": "float",
    "f64": "double",
    "int8": "int8_t",
    "uint8": "uint8_t",
    "int16": "int16_t",
    "uint16": "uint16_t",
    "int32": "int32_t",
    "uint32": "uint32_t",
    "int64": "int64_t",
    "uint64": "uint64_t",
}

_PARAM_RE = re.compile(r"(\w+)\(([^)]+)\)")


def _parse_space(space: str) -> int:
    match = re.match(r"([0-9_]+)B", space)
    if not match:
        return 0
    return int(match.group(1).replace("_", ""))


def compile_to_nasm(funcs: List[FunctionDef]) -> str:
    """Return NASM x86_64 assembly for ``funcs``.

    This is a very small subset that only emits prologue/epilogue and reserves
    stack space based on ``@space`` attributes.
    """
    lines = ["; Auto-generated NASM for SafeLang"]
    for fn in funcs:
        lines.append(f"global {fn.name}")
    lines.append("")
    for fn in funcs:
        space = _parse_space(fn.space)
        lines.append(f"{fn.name}:")
        lines.append("    push rbp")
        lines.append("    mov rbp, rsp")
        if space:
            lines.append(f"    sub rsp, {space}")
        lines.append("    ; TODO: compile body")
        if space:
            lines.append(f"    add rsp, {space}")
        lines.append("    pop rbp")
        lines.append("    ret")


def _parse_params(lines: List[str]) -> List[str]:
    params = []
    for ln in lines:
        m = _PARAM_RE.search(ln)
        if not m:
            continue
        typ, name = m.group(1), m.group(2)
        c_typ = _TYPE_MAP.get(typ, "int")
        params.append(f"{c_typ} {name}")
    return params


def generate_c(funcs: List[FunctionDef]) -> str:
    """Generate a very small C translation of ``funcs``."""
    lines = ["// Generated by SafeLang", "#include <stdint.h>", ""]
    for fn in funcs:
        params = _parse_params(fn.consume)
        lines.append(f"/* {fn.name}: @space {fn.space} @time {fn.time} */")
        lines.append(f"void {fn.name}({', '.join(params)}) {{")
        body = fn.body.strip().splitlines()
        for b in body:
            lines.append("    " + b.rstrip())
        lines.append("}")

        lines.append("")
    return "\n".join(lines)


__all__ = ["compile_to_nasm", "generate_c"]
